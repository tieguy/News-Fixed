#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2025 Luis Villa <luis@lu.is>
#
# SPDX-License-Identifier: BlueOak-1.0.0

"""
News, Fixed - Unified wrapper for fetching FTN content and generating newspapers.

Usage:
  ./news-fixed fetch <url>              Fetch FTN content from URL
  ./news-fixed parse <html-file>        Parse HTML to JSON
  ./news-fixed curate <json-file>       Interactively curate stories
  ./news-fixed generate <json-file>     Curate stories (default) and generate PDFs
  ./news-fixed run <url>                Complete pipeline (fetch, parse, curate, generate)
  ./news-fixed test                     Generate test newspaper

Flags:
  --redo-curation                       Re-run the interactive TUI in generate/run commands
"""

import sys
import os
import subprocess
from pathlib import Path

# Get project root (where this script lives)
PROJECT_ROOT = Path(__file__).parent.resolve()

# Check if we're running under uv (look for VIRTUAL_ENV or .venv)
def is_uv_env():
    """Check if we're running in a uv-managed environment."""
    venv_path = PROJECT_ROOT / ".venv"
    if not venv_path.exists():
        return False
    # Check if current Python is from this venv
    return str(venv_path) in sys.prefix

# If not in uv env, re-exec with uv run
if not is_uv_env():
    os.execvp("uv", ["uv", "run", "python"] + sys.argv)

# Now we're in the uv environment with all dependencies
import json
from datetime import datetime
import click

CODE_DIR = PROJECT_ROOT / "code"

# Standard paths (relative to project root)
DATA_DIR = PROJECT_ROOT / "data"
DATA_RAW_DIR = DATA_DIR / "raw"
DATA_PROCESSED_DIR = DATA_DIR / "processed"
OUTPUT_DIR = PROJECT_ROOT / "output"

# Firefox profile for FTN (in project root)
FIREFOX_PROFILE = PROJECT_ROOT / ".firefox-profile-ftn"


def ensure_dirs():
    """Create standard directories if they don't exist."""
    for d in [DATA_RAW_DIR, DATA_PROCESSED_DIR, OUTPUT_DIR]:
        d.mkdir(parents=True, exist_ok=True)


def get_issue_number_from_url(url: str) -> str:
    """Extract issue number from FTN URL.

    Handles URL formats like:
    - https://fixthenews.com/p/322-shinga-ray-of-hope-...
    - https://fixthenews.com/p/fix-the-news-319
    """
    import re
    # Try /p/NNN-slug format (current FTN format)
    match = re.search(r'fixthenews\.com/p/(\d+)', url)
    if match:
        return match.group(1)
    # Try fix-the-news-NNN format (older format)
    match = re.search(r'fix-the-news-(\d+)', url)
    if match:
        return match.group(1)
    # Fallback: use timestamp
    return datetime.now().strftime('%Y%m%d-%H%M%S')


@click.group()
def cli():
    """News, Fixed - Transform positive news into daily newspapers for kids."""
    pass


@cli.command()
@click.argument('url')
@click.option('--force-login', is_flag=True, help='Force interactive login')
@click.option('--headless/--no-headless', default=True, help='Run browser in headless mode')
def fetch(url, force_login, headless):
    """Fetch FTN content from URL and save to data/raw/."""
    ensure_dirs()

    click.echo(f"ðŸ“¥ Fetching content from {url}")

    # Import fetch function
    sys.path.insert(0, str(CODE_DIR))
    from src.fetch_ftn_clean import fetch_ftn_latest

    # Determine output filename
    issue_num = get_issue_number_from_url(url)
    output_file = DATA_RAW_DIR / f"FTN-{issue_num}.html"

    try:
        saved_path = fetch_ftn_latest(
            output_dir=str(DATA_RAW_DIR),
            headless=headless,
            force_login=force_login,
            url=url
        )

        click.echo(f"âœ… Saved to: {saved_path}")
        click.echo(f"\nðŸ’¡ Next step: ./news-fixed parse {saved_path}")

    except Exception as e:
        click.echo(f"âŒ Error fetching content: {e}")
        sys.exit(1)


@cli.command()
@click.argument('html_file', type=click.Path(exists=True))
@click.option('--output', '-o', type=click.Path(), help='Output JSON file (default: auto-generate)')
def parse(html_file, output):
    """Parse FTN HTML file to JSON format."""
    ensure_dirs()

    html_path = Path(html_file)
    click.echo(f"ðŸ“– Parsing {html_path.name}")

    # Import parser
    sys.path.insert(0, str(CODE_DIR))
    from src.ftn_to_json import create_json_from_ftn

    # Auto-generate output filename if not specified
    if not output:
        # Extract issue number from filename (e.g., FTN-317.html -> ftn-317.json)
        import re
        match = re.search(r'FTN-(\d+)', html_path.name)
        if match:
            issue_num = match.group(1)
            output = DATA_PROCESSED_DIR / f"ftn-{issue_num}.json"
        else:
            output = DATA_PROCESSED_DIR / f"{html_path.stem}.json"
    else:
        output = Path(output)

    try:
        json_path = create_json_from_ftn(str(html_path), str(output))
        click.echo(f"âœ… Saved to: {json_path}")
        click.echo(f"\nðŸ’¡ Next step: ./news-fixed generate {json_path}")

    except Exception as e:
        click.echo(f"âŒ Error parsing HTML: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


@cli.command()
@click.argument('json_file', type=click.Path(exists=True))
@click.option('--output', '-o', type=click.Path(), help='Output JSON file (default: auto-generate)')
@click.option('--dry-run', is_flag=True, help='Preview without saving')
def curate(json_file, output, dry_run):
    """Interactively curate stories before generation."""
    ensure_dirs()

    # Build command for code/src/curate.py using uv run
    cmd = ['uv', 'run', 'python', str(CODE_DIR / "src" / "curate.py")]
    cmd.append(str(Path(json_file).resolve()))

    if output:
        cmd.extend(['--output', str(Path(output).resolve())])

    if dry_run:
        cmd.append('--dry-run')

    # Run the curator
    try:
        subprocess.run(cmd, cwd=PROJECT_ROOT, check=True)

    except subprocess.CalledProcessError as e:
        click.echo(f"âŒ Error during curation: {e}")
        sys.exit(1)


@cli.command()
@click.argument('json_file', type=click.Path(exists=True))
@click.option('--day', '-d', type=click.IntRange(1, 4), help='Generate specific day (1-4)')
@click.option('--all', 'generate_all', is_flag=True, help='Generate all 4 days')
@click.option('--combined', is_flag=True, help='Generate combined 8-page PDF with all 4 days')
@click.option('--output', '-o', type=click.Path(), help='Output directory (default: ./output)')
@click.option('--no-rewrite', is_flag=True, help='Skip AI rewriting')
@click.option('--redo-curation', is_flag=True, help='Re-run interactive story curation')
def generate(json_file, day, generate_all, combined, output, no_rewrite, redo_curation):
    """Generate PDF newspapers from JSON file."""
    ensure_dirs()

    if not output:
        output = OUTPUT_DIR

    json_path = Path(json_file).resolve()

    # Only run curation if explicitly requested with --redo-curation
    if redo_curation:
        click.echo("ðŸ“ Step 1/2: Curating stories...\n")

        # Auto-generate curated filename
        curated_path = json_path.parent / f"{json_path.stem}-curated.json"

        curate_cmd = ['uv', 'run', 'python', str(CODE_DIR / "src" / "curate.py")]
        curate_cmd.append(str(json_path))
        curate_cmd.extend(['--output', str(curated_path)])

        try:
            subprocess.run(curate_cmd, cwd=PROJECT_ROOT, check=True)
            # Use the curated file for generation
            json_path = curated_path
            click.echo(f"\nðŸ“° Step 2/2: Generating PDFs...\n")
        except subprocess.CalledProcessError as e:
            click.echo(f"âŒ Error during curation: {e}")
            sys.exit(1)
        except KeyboardInterrupt:
            click.echo("\n\nâŒ Curation cancelled by user")
            sys.exit(1)

    # Step 2: Build command for code/src/main.py using uv run
    cmd = ['uv', 'run', 'python', str(CODE_DIR / "src" / "main.py")]
    cmd.extend(['--input', str(json_path)])
    cmd.extend(['--output', str(Path(output).resolve())])

    if combined:
        cmd.append('--combined')
    elif generate_all:
        cmd.append('--all')
    elif day:
        cmd.extend(['--day', str(day)])
    else:
        # Default to generating all days
        cmd.append('--all')

    if no_rewrite:
        cmd.append('--no-rewrite')

    # Run the generator
    try:
        result = subprocess.run(cmd, cwd=PROJECT_ROOT, check=True)
        click.echo(f"\nâœ… PDFs generated in: {output}")

    except subprocess.CalledProcessError as e:
        click.echo(f"âŒ Error generating PDFs: {e}")
        sys.exit(1)


@cli.command()
@click.argument('url')
@click.option('--force-login', is_flag=True, help='Force interactive login')
@click.option('--no-rewrite', is_flag=True, help='Skip AI rewriting')
@click.option('--redo-curation', is_flag=True, help='Re-run interactive story curation')
def run(url, force_login, no_rewrite, redo_curation):
    """Complete pipeline: fetch, parse, curate, and generate from a URL."""
    ensure_dirs()

    num_steps = 4 if redo_curation else 3
    click.echo(f"ðŸš€ Running complete pipeline: fetch â†’ parse â†’ {'curate â†’ ' if redo_curation else ''}generate\n")

    # Step 1: Fetch
    sys.path.insert(0, str(CODE_DIR))
    from src.fetch_ftn_clean import fetch_ftn_latest

    click.echo(f"ðŸ“¥ Step 1/{num_steps}: Fetching content from {url}")
    issue_num = get_issue_number_from_url(url)

    try:
        html_path = fetch_ftn_latest(
            output_dir=str(DATA_RAW_DIR),
            headless=True,
            force_login=force_login,
            url=url
        )
        click.echo(f"   âœ… Saved HTML to: {html_path}\n")
    except Exception as e:
        click.echo(f"âŒ Error fetching: {e}")
        sys.exit(1)

    # Step 2: Parse
    click.echo(f"ðŸ“– Step 2/{num_steps}: Parsing HTML to JSON")
    from src.ftn_to_json import create_json_from_ftn

    json_output = DATA_PROCESSED_DIR / f"ftn-{issue_num}.json"

    try:
        json_path = create_json_from_ftn(str(html_path), str(json_output))
        click.echo(f"   âœ… Saved JSON to: {json_path}\n")
    except Exception as e:
        click.echo(f"âŒ Error parsing: {e}")
        sys.exit(1)

    # Step 3: Curate (only if --redo-curation flag is set)
    if redo_curation:
        click.echo(f"ðŸ“ Step 3/{num_steps}: Curating stories")

        curated_path = Path(json_path).parent / f"{Path(json_path).stem}-curated.json"

        curate_cmd = ['uv', 'run', 'python', str(CODE_DIR / "src" / "curate.py")]
        curate_cmd.append(str(json_path))
        curate_cmd.extend(['--output', str(curated_path)])

        try:
            subprocess.run(curate_cmd, cwd=PROJECT_ROOT, check=True)
            json_path = str(curated_path)
            click.echo(f"   âœ… Stories curated\n")
        except subprocess.CalledProcessError as e:
            click.echo(f"âŒ Error during curation: {e}")
            sys.exit(1)
        except KeyboardInterrupt:
            click.echo("\n\nâŒ Curation cancelled by user")
            sys.exit(1)

    # Step 4 (or 3): Generate
    click.echo(f"ðŸ“° Step {num_steps}/{num_steps}: Generating PDFs")

    cmd = ['uv', 'run', 'python', str(CODE_DIR / "src" / "main.py")]
    cmd.extend(['--input', str(Path(json_path).resolve())])
    cmd.extend(['--output', str(OUTPUT_DIR.resolve())])
    cmd.append('--all')  # Always generate all 4 days in run mode

    if no_rewrite:
        cmd.append('--no-rewrite')

    try:
        subprocess.run(cmd, cwd=PROJECT_ROOT, check=True)
        click.echo(f"\nâœ… Complete! PDFs are in: {OUTPUT_DIR}")

    except subprocess.CalledProcessError as e:
        click.echo(f"âŒ Error generating PDFs: {e}")
        sys.exit(1)


@cli.command()
def test():
    """Generate a test newspaper with sample data (no API calls)."""
    ensure_dirs()

    cmd = ['uv', 'run', 'python', str(CODE_DIR / "src" / "main.py")]
    cmd.extend(['--test', '--output', str(OUTPUT_DIR)])

    try:
        subprocess.run(cmd, cwd=PROJECT_ROOT, check=True)

    except subprocess.CalledProcessError as e:
        click.echo(f"âŒ Error generating test: {e}")
        sys.exit(1)


@cli.group()
def xkcd():
    """Manage xkcd comics for the newspaper."""
    pass


@xkcd.command()
@click.option('--count', '-n', default=10, help='Number of recent comics to fetch')
def fetch(count):
    """Fetch recent xkcd comics and analyze them."""
    ensure_dirs()

    sys.path.insert(0, str(CODE_DIR))
    from src.xkcd import XkcdManager

    manager = XkcdManager(data_dir=DATA_DIR)

    click.echo(f"Fetching {count} recent xkcd comics...")
    comics = manager.fetch_recent_comics(count=count)
    click.echo(f"Fetched {len(comics)} comics")

    # Analyze any that haven't been analyzed
    rejected = manager.load_rejected()
    analyzed_count = 0

    for comic in comics:
        comic_num = str(comic["num"])

        # Skip rejected
        if comic_num in rejected:
            click.echo(f"  #{comic['num']}: {comic['title']} (rejected)")
            continue

        # Check if already analyzed
        cache = manager.load_cache()
        if comic_num in cache and "analysis" in cache[comic_num]:
            click.echo(f"  #{comic['num']}: {comic['title']} (cached)")
            continue

        click.echo(f"  #{comic['num']}: {comic['title']} (analyzing...)")
        try:
            manager.analyze_comic(comic)
            analyzed_count += 1
        except Exception as e:
            click.echo(f"    Error: {e}")

    if analyzed_count > 0:
        click.echo(f"\nAnalyzed {analyzed_count} new comics")

    click.echo("\nRun './news-fixed xkcd candidates' to see recommendations")


@xkcd.command()
def candidates():
    """Show candidate comics for this week."""
    ensure_dirs()

    sys.path.insert(0, str(CODE_DIR))
    from src.xkcd import XkcdManager

    manager = XkcdManager(data_dir=DATA_DIR)

    # Check if already selected
    week_selections = manager.get_week_selections()
    if any(week_selections.values()):
        day_names = {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday'}
        click.echo("Already selected for this week:")
        for day, comic_num in week_selections.items():
            if comic_num:
                click.echo(f"  Day {day} ({day_names[day]}): #{comic_num}")
        click.echo("Run './news-fixed xkcd select <num> --day <1-4>' to change selection")
        return

    candidates = manager.get_candidates()

    if not candidates:
        click.echo("No candidates available. Run './news-fixed xkcd fetch' first.")
        return

    click.echo("Candidate comics for this week:\n")

    for i, comic in enumerate(candidates, 1):
        analysis = comic.get("analysis", {})
        click.echo(f"{i}. #{comic['num']}: {comic['title']}")
        click.echo(f"   Alt: {comic['alt'][:80]}..." if len(comic['alt']) > 80 else f"   Alt: {comic['alt']}")
        click.echo(f"   Summary: {analysis.get('brief_summary', 'N/A')}")
        click.echo(f"   Tags: {', '.join(analysis.get('topic_tags', []))}")
        click.echo(f"   View: https://xkcd.com/{comic['num']}/")
        click.echo()

    click.echo("Select with: ./news-fixed xkcd select <number> --day <1-4>")
    click.echo("Reject with: ./news-fixed xkcd reject <number> <reason>")


@xkcd.command()
@click.argument('comic_num', type=int)
@click.option('--day', '-d', type=click.IntRange(1, 4), default=1,
              help='Day to show comic (1=Mon, 2=Tue, 3=Wed, 4=Thu)')
def select(comic_num, day):
    """Select a comic for this week's newspaper."""
    ensure_dirs()

    sys.path.insert(0, str(CODE_DIR))
    from src.xkcd import XkcdManager
    from datetime import timedelta

    # Target the upcoming newspaper week (next Monday, or today if Monday)
    today = datetime.now()
    weekday = today.weekday()  # Mon=0, Sun=6
    if weekday == 0:  # Monday
        target_date = today
    else:
        days_until_monday = 7 - weekday
        target_date = today + timedelta(days=days_until_monday)

    day_names = {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday'}
    manager = XkcdManager(data_dir=DATA_DIR)
    manager.select_comic(comic_num, day=day, week_date=target_date)

    iso_week = target_date.isocalendar()
    click.echo(f"Selected #{comic_num} for {day_names[day]} (week {iso_week.year}-W{iso_week.week:02d})")


@xkcd.command()
@click.argument('comic_num', type=int)
@click.argument('reason', type=click.Choice([
    'too_complex', 'adult_humor', 'too_dark',
    'multi_panel', 'requires_context', 'other'
]))
def reject(comic_num, reason):
    """Reject a comic (won't be shown as candidate again)."""
    ensure_dirs()

    sys.path.insert(0, str(CODE_DIR))
    from src.xkcd import XkcdManager

    manager = XkcdManager(data_dir=DATA_DIR)
    manager.reject_comic(comic_num, reason)

    click.echo(f"Rejected #{comic_num} ({reason})")


@xkcd.command()
@click.argument('comic_num', type=int)
def show(comic_num):
    """Show details for a specific comic."""
    ensure_dirs()

    sys.path.insert(0, str(CODE_DIR))
    from src.xkcd import XkcdManager

    manager = XkcdManager(data_dir=DATA_DIR)
    cache = manager.load_cache()

    comic_key = str(comic_num)
    if comic_key not in cache:
        click.echo(f"Comic #{comic_num} not in cache. Fetching...")
        comic = manager.fetch_comic(comic_num)
    else:
        comic = cache[comic_key]

    click.echo(f"\n#{comic['num']}: {comic['title']}")
    click.echo(f"Date: {comic['date']}")
    click.echo(f"Alt: {comic['alt']}")
    click.echo(f"Image: {comic['img']}")
    click.echo(f"URL: https://xkcd.com/{comic['num']}/")

    analysis = comic.get("analysis")
    if analysis:
        click.echo(f"\nAnalysis:")
        click.echo(f"  Panels: {analysis.get('panel_count', 'N/A')}")
        click.echo(f"  Age-appropriate: {analysis.get('age_appropriate', 'N/A')}")
        click.echo(f"  Specialized knowledge: {analysis.get('requires_specialized_knowledge', 'N/A')}")
        click.echo(f"  Tags: {', '.join(analysis.get('topic_tags', []))}")
        click.echo(f"  Summary: {analysis.get('brief_summary', 'N/A')}")
    else:
        click.echo("\n(Not yet analyzed. Run './news-fixed xkcd fetch' to analyze.)")

    # Check if rejected
    rejected = manager.load_rejected()
    if comic_key in rejected:
        click.echo(f"\nREJECTED: {rejected[comic_key]['reason']}")


if __name__ == '__main__':
    cli()
